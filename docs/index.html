<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像メタデータ解析・削除ツール v14</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #007bff;
            --primary-hover-color: #0056b3;
            --secondary-color: #6c757d;
            --secondary-hover-color: #5a6268;
            --text-color: #e0e0e0;
            --border-color: #444;
            --key-color: #17a2b8;
            --key-stealth-color: #28a745;
            --key-not-found-color: #6c757d;
            --error-color: #dc3545;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body {
            font-family: var(--font-family);
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: var(--surface-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        h1 {
            text-align: center;
            color: #fff;
            margin-top: 0;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        .custom-button {
            flex-grow: 1;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 8px;
            padding: 12px 15px;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .custom-button:hover { background-color: var(--primary-hover-color); }
        .delete-btn {
            background-color: var(--secondary-color);
            margin-top: 15px;
        }
        .delete-btn:hover { background-color: var(--secondary-hover-color); }
        .custom-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .custom-button:active { transform: scale(0.98); }
        input[type="file"] { display: none; }
        #results { margin-top: 20px; }
        .result-item {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        .result-item img {
            max-width: 100%;
            height: auto;
            display: block;
            margin-bottom: 15px;
            border-radius: 5px;
        }
        .metadata-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #fff;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        .metadata {
            font-family: "SF Mono", "Consolas", "Menlo", monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #111;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            font-size: 0.9em;
        }
        .metadata-entry { margin-bottom: 8px; }
        .metadata-key { font-weight: bold; color: var(--key-color); }
        .stealth-key { font-weight: bold; color: var(--key-stealth-color); }
        .not-found-key { font-weight: bold; color: var(--key-not-found-color); }
        .error-key { font-weight: bold; color: var(--error-color); }
        .status-message {
            text-align: center;
            font-size: 18px;
            color: #888;
            padding: 40px 0;
        }
    </style>
    <script src="exif-reader.js"></script>
    <script src="pako.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>画像メタデータ解析・削除ツール 🖼️</h1>
        <div class="controls">
            <button id="fileSelectBtn" class="custom-button">ファイルを選択</button>
            <button id="folderSelectBtn" class="custom-button">フォルダを選択</button>
        </div>
        <input type="file" id="fileInput" multiple accept="image/jpeg, image/png, image/webp">
        <input type="file" id="folderInput" webkitdirectory>
        <div id="results">
             <p class="status-message">ファイルまたはフォルダを選択してください</p>
        </div>
    </div>
    <script>
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const fileSelectBtn = document.getElementById('fileSelectBtn');
        const folderSelectBtn = document.getElementById('folderSelectBtn');
        const resultsDiv = document.getElementById('results');

        fileSelectBtn.addEventListener('click', () => fileInput.click());
        folderSelectBtn.addEventListener('click', () => folderInput.click());
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        folderInput.addEventListener('change', (e) => handleFiles(e.target.files));

        async function handleFiles(files) {
            if (!files || files.length === 0) {
                resultsDiv.innerHTML = '<p class="status-message">ファイルが見つかりませんでした。</p>';
                return;
            }
            resultsDiv.innerHTML = '<p class="status-message">解析中...</p>';
            const validFiles = Array.from(files).filter(file => /\.(jpe?g|png|webp)$/i.test(file.name));
            if (validFiles.length === 0) {
                resultsDiv.innerHTML = '<p class="status-message">解析対象の画像ファイルが見つかりませんでした。</p>';
                return;
            }
            resultsDiv.innerHTML = '';
            for (const file of validFiles) {
                await processFile(file);
            }
        }

        async function processFile(file) {
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            resultItem._file = file;

            const url = URL.createObjectURL(file);
            const img = document.createElement('img');
            const p1 = new Promise((resolve) => {
                img.onload = () => {
                    const maxDim = 720;
                    const { naturalWidth: w, naturalHeight: h } = img;
                    if (w > maxDim || h > maxDim) {
                        if (w > h) img.width = maxDim;
                        else img.height = maxDim;
                    }
                    resolve();
                };
                img.onerror = () => { console.error("Image failed to load:", url); resolve(); };
                img.src = url;
            });
            resultItem.appendChild(img);
            await p1;

            const metadataContainer = document.createElement('div');
            metadataContainer.className = 'metadata-container';
            metadataContainer.innerHTML = `<h3>メタデータ: ${escapeHtml(file.name)}</h3>`;
            const metadataDiv = document.createElement('div');
            metadataDiv.className = 'metadata';
            
            const { metadata, stealthAnalysis } = await extractMetadata(file, img);
            resultItem._stealthAnalysis = stealthAnalysis; // 削除処理で使えるように結果を保持

            URL.revokeObjectURL(url);
            
            if (metadata.length > 0) {
                metadata.forEach(entry => {
                    const p = document.createElement('p');
                    p.className = 'metadata-entry';
                    let keyClass = 'metadata-key';
                    if (entry.isError) keyClass = 'error-key';
                    if (entry.isStealth) keyClass = 'stealth-key';
                    if (entry.isNotFound) keyClass = 'not-found-key';
                    p.innerHTML = `<span class="${keyClass}">${entry.key}:</span> ${escapeHtml(entry.value)}`;
                    metadataDiv.appendChild(p);
                });
            } else {
                metadataDiv.textContent = '埋め込まれている可能性のあるプロンプト情報は見つかりませんでした。';
            }
            
            metadataContainer.appendChild(metadataDiv);
            resultItem.appendChild(metadataContainer);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'メタデータを削除して保存';
            deleteBtn.className = 'custom-button delete-btn';
            deleteBtn.onclick = handleMetadataDelete;
            resultItem.appendChild(deleteBtn);

            resultsDiv.appendChild(resultItem);
        }

        async function handleMetadataDelete(event) {
            const button = event.target;
            const resultItem = button.closest('.result-item');
            const file = resultItem._file;
            const analysis = resultItem._stealthAnalysis;
            if (!file) return;

            button.textContent = '処理中...';
            button.disabled = true;

            try {
                const image = new Image();
                const url = URL.createObjectURL(file);
                
                image.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = image.naturalWidth;
                    canvas.height = image.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(image, 0, 0);

                    const isPng = file.type === 'image/png';
                    let modifyPixels = !isPng; // PNG以外は常にピクセルを修正
                    if (isPng && (analysis.foundInAlpha || analysis.foundInRgb)) {
                        modifyPixels = true;
                    }

                    if (modifyPixels) {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const pixels = imageData.data;
                        
                        const randomizeRgb = !isPng || analysis.foundInRgb;
                        const normalizeAlpha = !isPng || analysis.foundInAlpha;

                        for (let i = 0; i < pixels.length; i += 4) {
                            if (randomizeRgb) {
                                pixels[i]   ^= (Math.random() < 0.5 ? 0 : 1);
                                pixels[i+1] ^= (Math.random() < 0.5 ? 0 : 1);
                                pixels[i+2] ^= (Math.random() < 0.5 ? 0 : 1);
                            }
                            if (normalizeAlpha) {
                                pixels[i+3] = 255;
                            }
                        }
                        ctx.putImageData(imageData, 0, 0);
                    }

                    canvas.toBlob((blob) => {
                        const newUrl = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = newUrl;
                        a.download = getClearFilename(file.name);
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(newUrl);
                        button.textContent = 'メタデータを削除して保存';
                        button.disabled = false;
                    }, file.type, 0.95);
                    
                    URL.revokeObjectURL(url);
                };
                image.src = url;

            } catch (e) {
                console.error("削除処理中にエラー:", e);
                alert("エラーが発生しました: " + e.message);
                button.textContent = 'メタデータを削除して保存';
                button.disabled = false;
            }
        }
        
        function getClearFilename(originalName) {
            const parts = originalName.split('.');
            const ext = parts.pop();
            return `${parts.join('.')}_clear.${ext}`;
        }

        async function extractMetadata(file, imageElement) {
            const results = { metadata: [], stealthAnalysis: { foundInAlpha: false, foundInRgb: false } };
            try {
                const buffer = await file.arrayBuffer();
                
                if (/\.webp$/i.test(file.name)) {
                    const webpChunks = parseWebP(new Uint8Array(buffer));
                    if (webpChunks.exifChunks.length > 0) {
                        webpChunks.exifChunks.forEach((chunk, i) => {
                             try {
                                 const tags = ExifReader.load(chunk.data.buffer, { expanded: true });
                                 if (tags?.exif?.UserComment?.value) results.metadata.push({ key: `WEBP EXIF #${i+1} (UserComment)`, value: parseUserComment(tags.exif.UserComment.value) });
                                 if (tags?.ifd0?.ImageDescription?.description) results.metadata.push({ key: `WEBP EXIF #${i+1} (ImageDescription)`, value: tags.ifd0.ImageDescription.description });
                             } catch (e) { results.metadata.push({ key: `WEBP EXIF #${i+1} 解析エラー`, value: e.message, isError: true }); }
                        });
                    }
                    if (webpChunks.xmpChunks.length > 0) {
                        webpChunks.xmpChunks.forEach((chunk, i) => {
                             try {
                                 const xmpText = new TextDecoder().decode(chunk.data);
                                 results.metadata.push({ key: `WEBP XMP #${i+1}`, value: formatXml(xmpText) });
                             } catch (e) { results.metadata.push({ key: `WEBP XMP #${i+1} 解析エラー`, value: e.message, isError: true }); }
                        });
                    }
                } else {
                    if (typeof ExifReader !== 'undefined' && ExifReader) {
                        try {
                            const tags = ExifReader.load(buffer, { expanded: true });
                            if (tags?.exif?.UserComment?.value) results.metadata.push({ key: 'EXIF (UserComment)', value: parseUserComment(tags.exif.UserComment.value) });
                            if (tags?.ifd0?.ImageDescription?.description) results.metadata.push({ key: 'EXIF (ImageDescription)', value: tags.ifd0.ImageDescription.description });
                            if (tags?.xmp?.description) results.metadata.push({ key: 'XMP', value: formatXml(tags.xmp.description) });
                        } catch (exifError) { results.metadata.push({ key: 'EXIF/XMP 解析エラー', value: exifError.message, isError: true }); }
                    } else { results.metadata.push({ key: 'ライブラリエラー', value: 'ExifReaderが読み込めませんでした。', isError: true }); }
                }
                
                if (/\.(jpe?g)$/i.test(file.name)) {
                    const comMarkers = findJpegComMarkers(new Uint8Array(buffer));
                    comMarkers.forEach((com, i) => results.metadata.push({ key: `JPEG COMマーカー[${i+1}]`, value: com }));
                } else if (/\.png$/i.test(file.name)) {
                    const pngChunks = findPngTextChunks(new Uint8Array(buffer));
                    pngChunks.forEach(chunk => {
                        results.metadata.push({ key: `PNG ${chunk.type} (${chunk.keyword})`, value: chunk.text });
                        if (chunk.type === 'iTXt' && chunk.keyword === 'XML:com.adobe.xmp') {
                            results.metadata.push({ key: 'XMP (from PNG iTXt)', value: formatXml(chunk.text) });
                        }
                    });

                    const canvas = document.createElement('canvas');
                    canvas.width = imageElement.naturalWidth;
                    canvas.height = imageElement.naturalHeight;
                    if (canvas.width > 0 && canvas.height > 0) {
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        ctx.drawImage(imageElement, 0, 0);
                        try {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const stealthInfo = findStealthInfo(imageData);
                            results.stealthAnalysis = { foundInAlpha: stealthInfo.foundInAlpha, foundInRgb: stealthInfo.foundInRgb };
                            
                            if (stealthInfo.foundInAlpha) {
                                results.metadata.push({ key: `Stealth PNG Info (Alpha)`, value: stealthInfo.alphaData, isStealth: true });
                            }
                            if (stealthInfo.foundInRgb) {
                                results.metadata.push({ key: `Stealth PNG Info (RGB)`, value: stealthInfo.rgbData, isStealth: true });
                            }
                            if (!stealthInfo.foundInAlpha && !stealthInfo.foundInRgb) {
                                results.metadata.push({ key: 'Stealth PNG Info', value: 'チェックしましたが、埋め込みデータは見つかりませんでした。', isNotFound: true });
                            }
                        } catch (e) { results.metadata.push({key: 'Canvas読み取りエラー', value: 'ピクセルデータを読めませんでした。', isError: true}); }
                    } else { results.metadata.push({ key: 'Stealth PNG Info', value: '画像サイズが0のためチェックできませんでした。', isNotFound: true });}
                }
            } catch (error) { results.metadata.push({ key: '致命的な解析エラー', value: error.message, isError: true }); }
            return results;
        }
        
        function findStealthInfo(imageData) {
            const { data, width, height } = imageData;
            let bit_stream_a = '', bit_stream_rgb = '';
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const i = (y * width + x) * 4;
                    bit_stream_rgb += (data[i] & 1).toString() + (data[i+1] & 1).toString() + (data[i+2] & 1).toString();
                    bit_stream_a += (data[i+3] & 1).toString();
                }
            }
            const result_a = processStealthStream(bit_stream_a, 'Alpha');
            const result_rgb = processStealthStream(bit_stream_rgb, 'RGB');
            return {
                foundInAlpha: !!result_a,
                foundInRgb: !!result_rgb,
                alphaData: result_a ? result_a.data : null,
                rgbData: result_rgb ? result_rgb.data : null
            };
        }
        function parseWebP(u8) { const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength); let off = 12; const exifChunks = [], xmpChunks = []; while (off + 8 <= u8.length) { const id = String.fromCharCode(u8[off], u8[off+1], u8[off+2], u8[off+3]); const size = dv.getUint32(off + 4, true); const dataOff = off + 8; const dataEnd = dataOff + size; if (dataEnd > u8.length) break; const data = u8.slice(dataOff, dataEnd); if (id === 'EXIF') exifChunks.push({ offset: off, size, data }); else if (id === 'XMP ') xmpChunks.push({ offset: off, size, data }); off = dataEnd + (size & 1); } return { exifChunks, xmpChunks }; }
        function processStealthStream(stream, mode) { const signatures = { 'stealth_pnginfo': { mode: 'Alpha', compressed: false }, 'stealth_pngcomp': { mode: 'Alpha', compressed: true }, 'stealth_rgbinfo': { mode: 'RGB', compressed: false }, 'stealth_rgbcomp': { mode: 'RGB', compressed: true }, }; const sig_len = 'stealth_pnginfo'.length * 8; if (stream.length < sig_len + 32) return null; const sig_binary = stream.substring(0, sig_len); const sig_text = binaryToText(sig_binary); if (!(sig_text in signatures) || signatures[sig_text].mode !== mode) return null; const compressed = signatures[sig_text].compressed; let current_stream = stream.substring(sig_len); const len_binary = current_stream.substring(0, 32); const param_len = parseInt(len_binary, 2); current_stream = current_stream.substring(32); if (current_stream.length < param_len) return null; const binary_data = current_stream.substring(0, param_len); const byte_array = new Uint8Array(binary_data.length / 8); for (let i = 0; i < byte_array.length; i++) { byte_array[i] = parseInt(binary_data.substring(i * 8, (i + 1) * 8), 2); } try { let decoded_data; if (compressed) { if (typeof pako === 'undefined') return { data: "[pako.js is not loaded, cannot decompress]", mode: mode, compressed: true }; decoded_data = pako.inflate(byte_array, { to: 'string' }); } else { decoded_data = new TextDecoder('utf-8', { fatal: true }).decode(byte_array); } return { data: decoded_data, mode: mode, compressed: compressed }; } catch (e) { return { data: "[decoding error]", mode: mode, compressed: compressed }; } }
        function binaryToText(binaryStr) { try { const bytes = new Uint8Array(binaryStr.length / 8); for (let i = 0; i < bytes.length; i++) { bytes[i] = parseInt(binaryStr.substr(i * 8, 8), 2); } return new TextDecoder('utf-8', { "fatal": false }).decode(bytes); } catch { return ''; } }
        function findJpegComMarkers(data) { const markers = []; let i = 0; while (i < data.length) { if (data[i] === 0xFF && data[i + 1] === 0xFE) { const length = (data[i + 2] << 8) + data[i + 3]; const commentBytes = data.slice(i + 4, i + 2 + length); try { markers.push(new TextDecoder('utf-8', { fatal: true }).decode(commentBytes)); } catch (e) { markers.push(new TextDecoder('sjis').decode(commentBytes) + ' (SJISとしてデコード)');} i += 2 + length; } else { i++; } } return markers; }
        function findPngTextChunks(data) { const chunks = []; let i = 8; const textDecoderUtf8 = new TextDecoder('utf-8'), textDecoderLatin1 = new TextDecoder('latin1'); while (i < data.length) { const view = new DataView(data.buffer); const length = view.getUint32(i, false); const type = textDecoderLatin1.decode(data.slice(i + 4, i + 8)); const dataStart = i + 8, dataEnd = dataStart + length; if (['tEXt', 'zTXt', 'iTXt'].includes(type)) { let keyword = '', text = ''; let keywordEnd = data.indexOf(0, dataStart); if (keywordEnd <= dataEnd && keywordEnd !== -1) { keyword = textDecoderLatin1.decode(data.slice(dataStart, keywordEnd)); const contentStart = keywordEnd + 1; if (type === 'tEXt') { text = textDecoderLatin1.decode(data.slice(contentStart, dataEnd)); } else if (type === 'zTXt') { if (data[contentStart] === 0) { try { text = textDecoderLatin1.decode(pako.inflate(data.slice(contentStart + 1, dataEnd)));} catch (e) { text = `[zTXt展開エラー: ${e.message}]`; } } } else if (type === 'iTXt') { const compressed = data[contentStart]; const textStart = data.indexOf(0, data.indexOf(0, contentStart + 2) + 1) + 1; let textBytes = data.slice(textStart, dataEnd); if (compressed === 1) { try { textBytes = pako.inflate(textBytes); } catch (e) { text = `[iTXt展開エラー: ${e.message}]`; textBytes = null;} } if(textBytes) text = textDecoderUtf8.decode(textBytes); } } if (keyword) chunks.push({ type, keyword, text }); } i = dataEnd + 4; } return chunks; }
        function parseUserComment(commentArray) { if (commentArray.length <= 8) return ''; const textBytes = new Uint8Array(commentArray.slice(8)); const code = new TextDecoder('ascii').decode(new Uint8Array(commentArray.slice(0, 5))); if (code.startsWith('ASCII')) return new TextDecoder('ascii').decode(textBytes); if (code.startsWith('JIS')) return new TextDecoder('sjis').decode(textBytes); try { return new TextDecoder('utf-8', { fatal: true }).decode(textBytes); } catch (e) { return new TextDecoder().decode(textBytes) + " (デコードエラーの可能性あり)"; } }
        function escapeHtml(str) { if (typeof str !== "string") return ""; return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;'); }
        function formatXml(xml) { if (typeof xml !== 'string') return ''; let formatted = '', pad = 0; xml = xml.replace(/(>)(<)(\/*)/g, '$1\r\n$2$3'); xml.split('\r\n').forEach(node => { let indent = 0; if (node.match(/.+<\/\w[^>]*>$/)) indent = 0; else if (node.match(/^<\/\w/)) { if (pad !== 0) pad -= 1; } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) indent = 1; let padding = ''; for (let i = 0; i < pad; i++) padding += '  '; formatted += padding + node + '\r\n'; pad += indent; }); return formatted.trim(); }
    </script>
</body>
</html>
