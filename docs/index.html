<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç”»åƒãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è§£æãƒ»å‰Šé™¤ãƒ„ãƒ¼ãƒ« v14</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --surface-color: #2c2c2c;
            --primary-color: #007bff;
            --primary-hover-color: #0056b3;
            --secondary-color: #6c757d;
            --secondary-hover-color: #5a6268;
            --text-color: #e0e0e0;
            --border-color: #444;
            --key-color: #17a2b8;
            --key-stealth-color: #28a745;
            --key-not-found-color: #6c757d;
            --error-color: #dc3545;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body {
            font-family: var(--font-family);
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: var(--surface-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }
        h1 {
            text-align: center;
            color: #fff;
            margin-top: 0;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        .custom-button {
            flex-grow: 1;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 8px;
            padding: 12px 15px;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .custom-button:hover { background-color: var(--primary-hover-color); }
        .delete-btn {
            background-color: var(--secondary-color);
            margin-top: 15px;
        }
        .delete-btn:hover { background-color: var(--secondary-hover-color); }
        .custom-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .custom-button:active { transform: scale(0.98); }
        input[type="file"] { display: none; }
        #results { margin-top: 20px; }
        .result-item {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        .result-item img {
            max-width: 100%;
            height: auto;
            display: block;
            margin-bottom: 15px;
            border-radius: 5px;
        }
        .metadata-container h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #fff;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
        }
        .metadata {
            font-family: "SF Mono", "Consolas", "Menlo", monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            background-color: #111;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            font-size: 0.9em;
        }
        .metadata-entry { margin-bottom: 8px; }
        .metadata-key { font-weight: bold; color: var(--key-color); }
        .stealth-key { font-weight: bold; color: var(--key-stealth-color); }
        .not-found-key { font-weight: bold; color: var(--key-not-found-color); }
        .error-key { font-weight: bold; color: var(--error-color); }
        .status-message {
            text-align: center;
            font-size: 18px;
            color: #888;
            padding: 40px 0;
        }
    </style>
    <script src="exif-reader.js"></script>
    <script src="pako.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>ç”»åƒãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è§£æãƒ»å‰Šé™¤ãƒ„ãƒ¼ãƒ« ğŸ–¼ï¸</h1>
        <div class="controls">
            <button id="fileSelectBtn" class="custom-button">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</button>
            <button id="folderSelectBtn" class="custom-button">ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ</button>
        </div>
        <input type="file" id="fileInput" multiple accept="image/jpeg, image/png, image/webp">
        <input type="file" id="folderInput" webkitdirectory>
        <div id="results">
             <p class="status-message">ãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„</p>
        </div>
    </div>
    <script>
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const fileSelectBtn = document.getElementById('fileSelectBtn');
        const folderSelectBtn = document.getElementById('folderSelectBtn');
        const resultsDiv = document.getElementById('results');

        fileSelectBtn.addEventListener('click', () => fileInput.click());
        folderSelectBtn.addEventListener('click', () => folderInput.click());
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        folderInput.addEventListener('change', (e) => handleFiles(e.target.files));

        async function handleFiles(files) {
            if (!files || files.length === 0) {
                resultsDiv.innerHTML = '<p class="status-message">ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</p>';
                return;
            }
            resultsDiv.innerHTML = '<p class="status-message">è§£æä¸­...</p>';
            const validFiles = Array.from(files).filter(file => /\.(jpe?g|png|webp)$/i.test(file.name));
            if (validFiles.length === 0) {
                resultsDiv.innerHTML = '<p class="status-message">è§£æå¯¾è±¡ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚</p>';
                return;
            }
            resultsDiv.innerHTML = '';
            for (const file of validFiles) {
                await processFile(file);
            }
        }

        async function processFile(file) {
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            resultItem._file = file;

            const url = URL.createObjectURL(file);
            const img = document.createElement('img');
            const p1 = new Promise((resolve) => {
                img.onload = () => {
                    const maxDim = 720;
                    const { naturalWidth: w, naturalHeight: h } = img;
                    if (w > maxDim || h > maxDim) {
                        if (w > h) img.width = maxDim;
                        else img.height = maxDim;
                    }
                    resolve();
                };
                img.onerror = () => { console.error("Image failed to load:", url); resolve(); };
                img.src = url;
            });
            resultItem.appendChild(img);
            await p1;

            const metadataContainer = document.createElement('div');
            metadataContainer.className = 'metadata-container';
            metadataContainer.innerHTML = `<h3>ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿: ${escapeHtml(file.name)}</h3>`;
            const metadataDiv = document.createElement('div');
            metadataDiv.className = 'metadata';
            
            const { metadata, stealthAnalysis } = await extractMetadata(file, img);
            resultItem._stealthAnalysis = stealthAnalysis; // å‰Šé™¤å‡¦ç†ã§ä½¿ãˆã‚‹ã‚ˆã†ã«çµæœã‚’ä¿æŒ

            URL.revokeObjectURL(url);
            
            if (metadata.length > 0) {
                metadata.forEach(entry => {
                    const p = document.createElement('p');
                    p.className = 'metadata-entry';
                    let keyClass = 'metadata-key';
                    if (entry.isError) keyClass = 'error-key';
                    if (entry.isStealth) keyClass = 'stealth-key';
                    if (entry.isNotFound) keyClass = 'not-found-key';
                    p.innerHTML = `<span class="${keyClass}">${entry.key}:</span> ${escapeHtml(entry.value)}`;
                    metadataDiv.appendChild(p);
                });
            } else {
                metadataDiv.textContent = 'åŸ‹ã‚è¾¼ã¾ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆæƒ…å ±ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚';
            }
            
            metadataContainer.appendChild(metadataDiv);
            resultItem.appendChild(metadataContainer);

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ä¿å­˜';
            deleteBtn.className = 'custom-button delete-btn';
            deleteBtn.onclick = handleMetadataDelete;
            resultItem.appendChild(deleteBtn);

            resultsDiv.appendChild(resultItem);
        }

        async function handleMetadataDelete(event) {
            const button = event.target;
            const resultItem = button.closest('.result-item');
            const file = resultItem._file;
            const analysis = resultItem._stealthAnalysis;
            if (!file) return;

            button.textContent = 'å‡¦ç†ä¸­...';
            button.disabled = true;

            try {
                const image = new Image();
                const url = URL.createObjectURL(file);
                
                image.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = image.naturalWidth;
                    canvas.height = image.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(image, 0, 0);

                    const isPng = file.type === 'image/png';
                    let modifyPixels = !isPng; // PNGä»¥å¤–ã¯å¸¸ã«ãƒ”ã‚¯ã‚»ãƒ«ã‚’ä¿®æ­£
                    if (isPng && (analysis.foundInAlpha || analysis.foundInRgb)) {
                        modifyPixels = true;
                    }

                    if (modifyPixels) {
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const pixels = imageData.data;
                        
                        const randomizeRgb = !isPng || analysis.foundInRgb;
                        const normalizeAlpha = !isPng || analysis.foundInAlpha;

                        for (let i = 0; i < pixels.length; i += 4) {
                            if (randomizeRgb) {
                                pixels[i]   ^= (Math.random() < 0.5 ? 0 : 1);
                                pixels[i+1] ^= (Math.random() < 0.5 ? 0 : 1);
                                pixels[i+2] ^= (Math.random() < 0.5 ? 0 : 1);
                            }
                            if (normalizeAlpha) {
                                pixels[i+3] = 255;
                            }
                        }
                        ctx.putImageData(imageData, 0, 0);
                    }

                    canvas.toBlob((blob) => {
                        const newUrl = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = newUrl;
                        a.download = getClearFilename(file.name);
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(newUrl);
                        button.textContent = 'ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ä¿å­˜';
                        button.disabled = false;
                    }, file.type, 0.95);
                    
                    URL.revokeObjectURL(url);
                };
                image.src = url;

            } catch (e) {
                console.error("å‰Šé™¤å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼:", e);
                alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
                button.textContent = 'ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ä¿å­˜';
                button.disabled = false;
            }
        }
        
        function getClearFilename(originalName) {
            const parts = originalName.split('.');
            const ext = parts.pop();
            return `${parts.join('.')}_clear.${ext}`;
        }

        async function extractMetadata(file, imageElement) {
            const results = { metadata: [], stealthAnalysis: { foundInAlpha: false, foundInRgb: false } };
            try {
                const buffer = await file.arrayBuffer();
                
                if (/\.webp$/i.test(file.name)) {
                    const webpChunks = parseWebP(new Uint8Array(buffer));
                    if (webpChunks.exifChunks.length > 0) {
                        webpChunks.exifChunks.forEach((chunk, i) => {
                             try {
                                 const tags = ExifReader.load(chunk.data.buffer, { expanded: true });
                                 if (tags?.exif?.UserComment?.value) results.metadata.push({ key: `WEBP EXIF #${i+1} (UserComment)`, value: parseUserComment(tags.exif.UserComment.value) });
                                 if (tags?.ifd0?.ImageDescription?.description) results.metadata.push({ key: `WEBP EXIF #${i+1} (ImageDescription)`, value: tags.ifd0.ImageDescription.description });
                             } catch (e) { results.metadata.push({ key: `WEBP EXIF #${i+1} è§£æã‚¨ãƒ©ãƒ¼`, value: e.message, isError: true }); }
                        });
                    }
                    if (webpChunks.xmpChunks.length > 0) {
                        webpChunks.xmpChunks.forEach((chunk, i) => {
                             try {
                                 const xmpText = new TextDecoder().decode(chunk.data);
                                 results.metadata.push({ key: `WEBP XMP #${i+1}`, value: formatXml(xmpText) });
                             } catch (e) { results.metadata.push({ key: `WEBP XMP #${i+1} è§£æã‚¨ãƒ©ãƒ¼`, value: e.message, isError: true }); }
                        });
                    }
                } else {
                    if (typeof ExifReader !== 'undefined' && ExifReader) {
                        try {
                            const tags = ExifReader.load(buffer, { expanded: true });
                            if (tags?.exif?.UserComment?.value) results.metadata.push({ key: 'EXIF (UserComment)', value: parseUserComment(tags.exif.UserComment.value) });
                            if (tags?.ifd0?.ImageDescription?.description) results.metadata.push({ key: 'EXIF (ImageDescription)', value: tags.ifd0.ImageDescription.description });
                            if (tags?.xmp?.description) results.metadata.push({ key: 'XMP', value: formatXml(tags.xmp.description) });
                        } catch (exifError) { results.metadata.push({ key: 'EXIF/XMP è§£æã‚¨ãƒ©ãƒ¼', value: exifError.message, isError: true }); }
                    } else { results.metadata.push({ key: 'ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¨ãƒ©ãƒ¼', value: 'ExifReaderãŒèª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚', isError: true }); }
                }
                
                if (/\.(jpe?g)$/i.test(file.name)) {
                    const comMarkers = findJpegComMarkers(new Uint8Array(buffer));
                    comMarkers.forEach((com, i) => results.metadata.push({ key: `JPEG COMãƒãƒ¼ã‚«ãƒ¼[${i+1}]`, value: com }));
                } else if (/\.png$/i.test(file.name)) {
                    const pngChunks = findPngTextChunks(new Uint8Array(buffer));
                    pngChunks.forEach(chunk => {
                        results.metadata.push({ key: `PNG ${chunk.type} (${chunk.keyword})`, value: chunk.text });
                        if (chunk.type === 'iTXt' && chunk.keyword === 'XML:com.adobe.xmp') {
                            results.metadata.push({ key: 'XMP (from PNG iTXt)', value: formatXml(chunk.text) });
                        }
                    });

                    const canvas = document.createElement('canvas');
                    canvas.width = imageElement.naturalWidth;
                    canvas.height = imageElement.naturalHeight;
                    if (canvas.width > 0 && canvas.height > 0) {
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        ctx.drawImage(imageElement, 0, 0);
                        try {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const stealthInfo = findStealthInfo(imageData);
                            results.stealthAnalysis = { foundInAlpha: stealthInfo.foundInAlpha, foundInRgb: stealthInfo.foundInRgb };
                            
                            if (stealthInfo.foundInAlpha) {
                                results.metadata.push({ key: `Stealth PNG Info (Alpha)`, value: stealthInfo.alphaData, isStealth: true });
                            }
                            if (stealthInfo.foundInRgb) {
                                results.metadata.push({ key: `Stealth PNG Info (RGB)`, value: stealthInfo.rgbData, isStealth: true });
                            }
                            if (!stealthInfo.foundInAlpha && !stealthInfo.foundInRgb) {
                                results.metadata.push({ key: 'Stealth PNG Info', value: 'ãƒã‚§ãƒƒã‚¯ã—ã¾ã—ãŸãŒã€åŸ‹ã‚è¾¼ã¿ãƒ‡ãƒ¼ã‚¿ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚', isNotFound: true });
                            }
                        } catch (e) { results.metadata.push({key: 'Canvasèª­ã¿å–ã‚Šã‚¨ãƒ©ãƒ¼', value: 'ãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚', isError: true}); }
                    } else { results.metadata.push({ key: 'Stealth PNG Info', value: 'ç”»åƒã‚µã‚¤ã‚ºãŒ0ã®ãŸã‚ãƒã‚§ãƒƒã‚¯ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚', isNotFound: true });}
                }
            } catch (error) { results.metadata.push({ key: 'è‡´å‘½çš„ãªè§£æã‚¨ãƒ©ãƒ¼', value: error.message, isError: true }); }
            return results;
        }
        
        function findStealthInfo(imageData) {
            const { data, width, height } = imageData;
            let bit_stream_a = '', bit_stream_rgb = '';
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const i = (y * width + x) * 4;
                    bit_stream_rgb += (data[i] & 1).toString() + (data[i+1] & 1).toString() + (data[i+2] & 1).toString();
                    bit_stream_a += (data[i+3] & 1).toString();
                }
            }
            const result_a = processStealthStream(bit_stream_a, 'Alpha');
            const result_rgb = processStealthStream(bit_stream_rgb, 'RGB');
            return {
                foundInAlpha: !!result_a,
                foundInRgb: !!result_rgb,
                alphaData: result_a ? result_a.data : null,
                rgbData: result_rgb ? result_rgb.data : null
            };
        }
        function parseWebP(u8) { const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength); let off = 12; const exifChunks = [], xmpChunks = []; while (off + 8 <= u8.length) { const id = String.fromCharCode(u8[off], u8[off+1], u8[off+2], u8[off+3]); const size = dv.getUint32(off + 4, true); const dataOff = off + 8; const dataEnd = dataOff + size; if (dataEnd > u8.length) break; const data = u8.slice(dataOff, dataEnd); if (id === 'EXIF') exifChunks.push({ offset: off, size, data }); else if (id === 'XMP ') xmpChunks.push({ offset: off, size, data }); off = dataEnd + (size & 1); } return { exifChunks, xmpChunks }; }
        function processStealthStream(stream, mode) { const signatures = { 'stealth_pnginfo': { mode: 'Alpha', compressed: false }, 'stealth_pngcomp': { mode: 'Alpha', compressed: true }, 'stealth_rgbinfo': { mode: 'RGB', compressed: false }, 'stealth_rgbcomp': { mode: 'RGB', compressed: true }, }; const sig_len = 'stealth_pnginfo'.length * 8; if (stream.length < sig_len + 32) return null; const sig_binary = stream.substring(0, sig_len); const sig_text = binaryToText(sig_binary); if (!(sig_text in signatures) || signatures[sig_text].mode !== mode) return null; const compressed = signatures[sig_text].compressed; let current_stream = stream.substring(sig_len); const len_binary = current_stream.substring(0, 32); const param_len = parseInt(len_binary, 2); current_stream = current_stream.substring(32); if (current_stream.length < param_len) return null; const binary_data = current_stream.substring(0, param_len); const byte_array = new Uint8Array(binary_data.length / 8); for (let i = 0; i < byte_array.length; i++) { byte_array[i] = parseInt(binary_data.substring(i * 8, (i + 1) * 8), 2); } try { let decoded_data; if (compressed) { if (typeof pako === 'undefined') return { data: "[pako.js is not loaded, cannot decompress]", mode: mode, compressed: true }; decoded_data = pako.inflate(byte_array, { to: 'string' }); } else { decoded_data = new TextDecoder('utf-8', { fatal: true }).decode(byte_array); } return { data: decoded_data, mode: mode, compressed: compressed }; } catch (e) { return { data: "[decoding error]", mode: mode, compressed: compressed }; } }
        function binaryToText(binaryStr) { try { const bytes = new Uint8Array(binaryStr.length / 8); for (let i = 0; i < bytes.length; i++) { bytes[i] = parseInt(binaryStr.substr(i * 8, 8), 2); } return new TextDecoder('utf-8', { "fatal": false }).decode(bytes); } catch { return ''; } }
        function findJpegComMarkers(data) { const markers = []; let i = 0; while (i < data.length) { if (data[i] === 0xFF && data[i + 1] === 0xFE) { const length = (data[i + 2] << 8) + data[i + 3]; const commentBytes = data.slice(i + 4, i + 2 + length); try { markers.push(new TextDecoder('utf-8', { fatal: true }).decode(commentBytes)); } catch (e) { markers.push(new TextDecoder('sjis').decode(commentBytes) + ' (SJISã¨ã—ã¦ãƒ‡ã‚³ãƒ¼ãƒ‰)');} i += 2 + length; } else { i++; } } return markers; }
        function findPngTextChunks(data) { const chunks = []; let i = 8; const textDecoderUtf8 = new TextDecoder('utf-8'), textDecoderLatin1 = new TextDecoder('latin1'); while (i < data.length) { const view = new DataView(data.buffer); const length = view.getUint32(i, false); const type = textDecoderLatin1.decode(data.slice(i + 4, i + 8)); const dataStart = i + 8, dataEnd = dataStart + length; if (['tEXt', 'zTXt', 'iTXt'].includes(type)) { let keyword = '', text = ''; let keywordEnd = data.indexOf(0, dataStart); if (keywordEnd <= dataEnd && keywordEnd !== -1) { keyword = textDecoderLatin1.decode(data.slice(dataStart, keywordEnd)); const contentStart = keywordEnd + 1; if (type === 'tEXt') { text = textDecoderLatin1.decode(data.slice(contentStart, dataEnd)); } else if (type === 'zTXt') { if (data[contentStart] === 0) { try { text = textDecoderLatin1.decode(pako.inflate(data.slice(contentStart + 1, dataEnd)));} catch (e) { text = `[zTXtå±•é–‹ã‚¨ãƒ©ãƒ¼: ${e.message}]`; } } } else if (type === 'iTXt') { const compressed = data[contentStart]; const textStart = data.indexOf(0, data.indexOf(0, contentStart + 2) + 1) + 1; let textBytes = data.slice(textStart, dataEnd); if (compressed === 1) { try { textBytes = pako.inflate(textBytes); } catch (e) { text = `[iTXtå±•é–‹ã‚¨ãƒ©ãƒ¼: ${e.message}]`; textBytes = null;} } if(textBytes) text = textDecoderUtf8.decode(textBytes); } } if (keyword) chunks.push({ type, keyword, text }); } i = dataEnd + 4; } return chunks; }
        function parseUserComment(commentArray) { if (commentArray.length <= 8) return ''; const textBytes = new Uint8Array(commentArray.slice(8)); const code = new TextDecoder('ascii').decode(new Uint8Array(commentArray.slice(0, 5))); if (code.startsWith('ASCII')) return new TextDecoder('ascii').decode(textBytes); if (code.startsWith('JIS')) return new TextDecoder('sjis').decode(textBytes); try { return new TextDecoder('utf-8', { fatal: true }).decode(textBytes); } catch (e) { return new TextDecoder().decode(textBytes) + " (ãƒ‡ã‚³ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ã®å¯èƒ½æ€§ã‚ã‚Š)"; } }
        function escapeHtml(str) { if (typeof str !== "string") return ""; return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;'); }
        function formatXml(xml) { if (typeof xml !== 'string') return ''; let formatted = '', pad = 0; xml = xml.replace(/(>)(<)(\/*)/g, '$1\r\n$2$3'); xml.split('\r\n').forEach(node => { let indent = 0; if (node.match(/.+<\/\w[^>]*>$/)) indent = 0; else if (node.match(/^<\/\w/)) { if (pad !== 0) pad -= 1; } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) indent = 1; let padding = ''; for (let i = 0; i < pad; i++) padding += '  '; formatted += padding + node + '\r\n'; pad += indent; }); return formatted.trim(); }
    </script>
</body>
</html>
